#!/usr/bin/env python3
import sys
from collections import defaultdict
from heapq import heappop, heappush


NO = "Impossible"  # type: str
INF = float('inf')  # type: float


class Heapque:
    def __init__(self, init=[], order_asc=True):
        self.que = init
        self.order_asc = order_asc
        self.datatype = None

    def __call__(self):
        return self.que

    def _set_datatype(self, data):
        if isinstance(data, list):
            self.datatype = "list"
        elif isinstance(data, tuple):
            self.datatype = "tuple"
        else:
            self.datatype = "scalar"

    def _process(self, data):
        if self.datatype is None:
            self._set_datatype(data)

        if self.order_asc:
            return data

        if self.datatype == "tuple":
            return (-data[0], *data[1:])
        elif self.datatype == "list":
            return [-data[0], *data[1:]]
        else:
            return -data

    def push(self, data):
        heappush(self.que, self._process(data))

    def pop(self):
        data = heappop(self.que)
        return self._process(data)


def solve(N: int, A: "List[int]", S: "List[str]", Q: int, U: "List[int]", V: "List[int]"):

    edges = [[] for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if S[i][j] == "Y":
                edges[i].append(j)

    def dijkstra(u):
        visited = [False] * N
        n_nodes = [INF] * N
        values = [-1] * N
        que = Heapque(order_asc=False)

        values[u] = A[u]
        n_nodes[u] = 0
        que.push((values[u], u, n_nodes[u]))

        while que():
            value, curr, n_node = que.pop()
            visited[curr] = True

            for nxt in edges[curr]:
                if visited[nxt]:
                    continue

                nxt_value = value + A[nxt]
                nxt_n_node = n_node + 1

                if ((n_nodes[nxt] > nxt_n_node) or
                    (n_nodes[nxt] == nxt_n_node and values[nxt] < nxt_value)
                ):
                    values[nxt] = nxt_value
                    n_nodes[nxt] = nxt_n_node
                    que.push((nxt_value, nxt, nxt_n_node))
        return values, n_nodes

    value_list, n_node_list = [], []
    for v in range(N):
        values, n_nodes = dijkstra(v)
        value_list.append(values)
        n_node_list.append(n_nodes)


    for u, v in zip(U, V):
        if value_list[u][v] == -1:
            print(NO)
        else:
            print(n_node_list[u][v], value_list[u][v])



# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    S = [next(tokens) for _ in range(N)]  # type: "List[str]"
    Q = int(next(tokens))  # type: int
    U = [int()] * (Q)  # type: "List[int]"
    V = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        U[i] = int(next(tokens)) - 1
        V[i] = int(next(tokens)) - 1
    solve(N, A, S, Q, U, V)

if __name__ == '__main__':
    main()
