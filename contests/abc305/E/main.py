#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float('inf')  # type: float


from heapq import heappop, heappush

class Heapque:
    def __init__(self, init=[], order_asc=True):
        self.que = init
        self.order_asc = order_asc
        self.datatype = None

    def __call__(self):
        return self.que

    def _set_datatype(self, data):
        if isinstance(data, list):
            self.datatype = "list"
        elif isinstance(data, tuple):
            self.datatype = "tuple"
        else:
            self.datatype = "scalar"

    def _process(self, data):
        if self.datatype is None:
            self._set_datatype(data)

        if self.order_asc:
            return data

        if self.datatype == "tuple":
            return (-data[0], *data[1:])
        elif self.datatype == "list":
            return [-data[0], *data[1:]]
        else:
            return -data

    def push(self, data):
        heappush(self.que, self._process(data))

    def pop(self):
        data = heappop(self.que)
        return self._process(data)


def solve(N: int, M: int, K: int, _a: "List[int]", _b: "List[int]", _p: "List[int]", _h: "List[int]"):
    edges = [[] for _ in range(N)]
    for a, b in zip(_a, _b):
        a -= 1
        b -= 1
        edges[a].append(b)
        edges[b].append(a)

    dist = [-1] * N

    que = Heapque(order_asc=False)

    for p, h in zip(_p, _h):
        p -= 1
        que.push((h, p))
        dist[p] = h

    while que():
        h, p = que.pop()

        if dist[p] != h:
            continue

        for n in edges[p]:
            if dist[n] < h - 1:
                que.push((h - 1, n))
                dist[n] = h - 1

    ans = [i + 1 for i, d in enumerate(dist) if d >= 0]

    print(len(ans))
    print(*ans)


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    a = [int()] * (M)  # type: "List[int]"
    b = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        a[i] = int(next(tokens))
        b[i] = int(next(tokens))
    p = [int()] * (K)  # type: "List[int]"
    h = [int()] * (K)  # type: "List[int]"
    for i in range(K):
        p[i] = int(next(tokens))
        h[i] = int(next(tokens))
    solve(N, M, K, a, b, p, h)

if __name__ == '__main__':
    main()
