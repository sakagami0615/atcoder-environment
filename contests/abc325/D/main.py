#!/usr/bin/env python3
import sys
from collections import defaultdict

from heapq import heappop, heappush

class Heapque:

    def __init__(self, init=None, order_asc=True):
        self.que = [] if init is None else init
        self.order_asc = order_asc
        self.datatype = None

    def __call__(self):
        return self.que

    def _set_datatype(self, data):
        if isinstance(data, list):
            self.datatype = "list"
        elif isinstance(data, tuple):
            self.datatype = "tuple"
        else:
            self.datatype = "scalar"

    def _process(self, data):
        if self.datatype is None:
            self._set_datatype(data)

        if self.order_asc:
            return data

        if self.datatype == "tuple":
            return (-data[0], *data[1:])
        elif self.datatype == "list":
            return [-data[0], *data[1:]]
        else:
            return -data

    def push(self, data):
        heappush(self.que, self._process(data))

    def pop(self):
        data = heappop(self.que)
        return self._process(data)


def solve(N: int, T: "List[int]", D: "List[int]"):

    correct = defaultdict(list)
    for i, (t, d) in enumerate(zip(T, D)):
        correct[t].append((i, t, d))

    key = sorted(correct.keys())
    n_key = len(key)
    curr_idx = 0

    que = Heapque()
    init = True
    last_t = 0
    ans = 0
    while init or que.que:
        if not init:
            while que.que:
                # 印字機から出力し、t + dの値がlast_tより大きい場合は印字することができる。
                # 印字出来たら、次の印字までのインターバルを反映（last_t + 1）
                num, t, i = que.pop()
                if num >= last_t:
                    ans += 1
                    last_t += 1

                # last_tが時刻tもしくが次の参照時間と同じになったら、
                # 次の商品が入ってくるので、ループを抜ける
                if (t >= last_t) or (curr_idx < n_key and last_t >= key[curr_idx]):
                    break

        # 商品が残っている場合は追加していく
        if curr_idx < n_key:
            for i, t, d in correct[key[curr_idx]]:
                que.push((t + d, t, i))
            # 参照した時刻は保存し、印字機から出るタイミングの処理で使用する
            last_t = key[curr_idx]
            curr_idx += 1

        init = False

    print(ans)


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    T = [int()] * (N)  # type: "List[int]"
    D = [int()] * (N)  # type: "List[int]"
    for i in range(N):
        T[i] = int(next(tokens))
        D[i] = int(next(tokens))
    solve(N, T, D)

if __name__ == '__main__':
    main()
