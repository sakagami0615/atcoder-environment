#!/usr/bin/env python3
import sys
from collections import defaultdict
sys.setrecursionlimit(10 ** 8)

MOD = 998244353  # type: int


def arg_cast(func):
    def wrapper(*args):
        s, n = args
        if not isinstance(s, ModInt): s = ModInt(s)
        if not isinstance(n, ModInt): n = ModInt(n)
        return func(s, n)
    return wrapper

class ModInt:
    def __init__(self, x): self.x = x % MOD
    def __str__(self): return str(self.x)
    @arg_cast
    def __add__(self, n): return ModInt(self.x + n.x)
    @arg_cast
    def __sub__(self, n): return ModInt(self.x - n.x)
    @arg_cast
    def __rsub__(self, n): return ModInt(n.x - self.x)
    @arg_cast
    def __mul__(self, n): return ModInt(self.x * n.x)
    @arg_cast
    def __pow__(self, n): return ModInt(pow(self.x, n.x, MOD))
    @arg_cast
    def __rpow__(self, n): return ModInt(pow(n.x, self.x, MOD))
    @arg_cast
    def __truediv__(self, n): return ModInt(self.x * pow(n.x, MOD - 2, MOD))
    @arg_cast
    def __rtruediv__(self, n): return ModInt(n.x * pow(self.x, MOD - 2, MOD))
    __repr__ = __str__
    __radd__ = __add__
    __rmul__ = __mul__
    __floordiv__ = __truediv__
    __rfloordiv__ = __rtruediv__


def solve(N: int):

    memo = defaultdict(lambda: None)

    def dp(n):
        nonlocal memo
        if n == N: return ModInt(1)
        if n > N: return ModInt(0)

        if memo[n] is not None:
            return memo[n]

        # dp[n] = 1/6 * (dp[n] + dp[2n] + dp[3n] + dp[4n] + dp[5n] + dp[6n])
        # dp[n] -  dp[n]/6 = 1/6 * (dp[2n] + dp[3n] + dp[4n] + dp[5n] + dp[6n])
        # (1 - 1/6) * dp[n] = 1/6 * (dp[2n] + dp[3n] + dp[4n] + dp[5n] + dp[6n])
        # (5/6) * dp[n] = 1/6 * (dp[2n] + dp[3n] + dp[4n] + dp[5n] + dp[6n])
        # dp[n] = 1/5 * (dp[2n] + dp[3n] + dp[4n] + dp[5n] + dp[6n])
        calc = ModInt(0)
        for i in range(2, 7):
            calc += dp(n * i) / 5
        memo[n] = calc
        return memo[n]

    ans = dp(1)
    print(ans)

# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    solve(N)

if __name__ == '__main__':
    main()
