#!/usr/bin/env python3
import sys
from collections import defaultdict
INF = float('inf')  # type: float



class SegTree:

    def op_rmq_min(x, y):
        return min(x, y)

    def e_rmq_min():
        return float('INF')

    def op_rmq_max(x, y):
        return max(x, y)

    def e_rmq_max():
        return -float('INF')

    def op_rsq(x, y):
        return x + y

    def e_rsq():
        return 0

    def __init__(self, init_tree, op=op_rmq_min, e=e_rmq_min):
        self.op = op
        self.e = e
        self.n = 1 << (len(init_tree) - 1).bit_length()
        self.tree = [self.e()] * 2 * self.n

        for i, v in enumerate(init_tree):
            self.tree[self.n + i] = v

        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.op(self.tree[2 * i], self.tree[2 * i + 1])

    def get(self, k):
        return self.tree[self.n + k]

    def update(self, k, x):
        k += self.n
        self.tree[k] = x
        while k > 1:
            k >>= 1
            self.tree[k] = self.op(self.tree[2 * k], self.tree[2 * k + 1])

    def query(self, l, r):
        l += self.n
        r += self.n

        s = self.e()

        while l < r:
            if l & 1:
                s = self.op(s, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                s = self.op(s, self.tree[r])
            l >>= 1
            r >>= 1

        return s


class MultiSet:

    def __init__(self, n):
        self.n = n
        self.cnt = [0] * self.n
        self.segtree_min = SegTree([n - 1]*self.n, SegTree.op_rmq_min, SegTree.e_rmq_min)
        self.segtree_max = SegTree([0]*self.n, SegTree.op_rmq_max, SegTree.e_rmq_max)

    def add(self, x):
        if self.cnt[x] == 0:
            self.segtree_min.update(x, x)
            self.segtree_max.update(x, x)
        self.cnt[x] += 1

    def delete(self, x):
        self.cnt[x] -= 1
        if self.cnt[x] == 0:
            self.segtree_min.update(x, self.n - 1)
            self.segtree_max.update(x, 0)

    def pop_max(self):
        x_max = self.segtree_max.query(0, self.n - 1)
        self.delete(x_max)
        return x_max

    def pop_min(self):
        x_min = self.segtree_min.query(0, self.n - 1)
        self.delete(x_min)
        return x_min

    def search_max(self):
        return self.segtree_max.query(0, self.n - 1)

    def search_min(self):
        return self.segtree_min.query(0, self.n - 1)

    def lower_bound(self, x):
        return self.segtree_max.query(0, x)

    def upper_bound(self, x):
        return self.segtree_min.query(x, self.n)

    def contains(self, x):
        return bool(self.cnt[x])


def solve(N: int, K: int, Q: int, X: "List[int]", Y: "List[int]"):

    enable_set = MultiSet(Q + N)
    stock_set = MultiSet(Q + N)

    n_enable = K
    n_stock = N - K

    for _ in range(n_enable):
        enable_set.add(0)
    for _ in range(n_stock):
        stock_set.add(0)

    a_list = [0] * N
    a_sum = 0

    def update():
        nonlocal enable_set, stock_set, n_stock, n_enable, a_sum
        while n_enable < K:
            stock_max = stock_set.pop_max()
            enable_set.add(stock_max)
            n_stock -= 1
            n_enable += 1
            a_sum += stock_max

        if n_enable == 0 or n_stock == 0:
            return

        while True:
            enable_min = enable_set.search_min()
            stock_max = stock_set.search_max()

            if enable_min >= stock_max:
                break

            a_sum += (stock_max - enable_min)

            enable_set.add(stock_max)
            enable_set.delete(enable_min)
            stock_set.add(enable_min)
            stock_set.delete(stock_max)

    def add(v):
        nonlocal stock_set, n_stock
        stock_set.add(v)
        n_stock += 1
        update()

    def erase(v):
        nonlocal enable_set, stock_set, n_stock, n_enable, a_sum
        if enable_set.contains(v):
            enable_set.delete(v)
            a_sum -= v
            n_enable -= 1
        else:
            stock_set.delete(v)
            n_stock -= 1
        update()

    for x, y in zip(X, Y):
        x -= 1

        prev_y = a_list[x]
        add(y)
        erase(prev_y)
        a_list[x] = y

        print(a_sum)




# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, K, Q, X, Y)

if __name__ == '__main__':
    main()
