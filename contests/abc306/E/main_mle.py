#!/usr/bin/env python3
import sys
from collections import defaultdict
INF = float('inf')  # type: float


# Segment Tree base class
class SegTree:
    def __init__(self, init_tree, op, e):
        self.op = op
        self.e = e
        self.n = 1 << (len(init_tree) - 1).bit_length()
        self.tree = [self.e()] * 2 * self.n
        for i, v in enumerate(init_tree):
            self.tree[self.n + i] = v
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.op(self.tree[2 * i], self.tree[2 * i + 1])

    def get(self, k):
        return self.tree[self.n + k]

    def update(self, k, x):
        k += self.n
        self.tree[k] = x
        while k > 1:
            k >>= 1
            self.tree[k] = self.op(self.tree[2 * k], self.tree[2 * k + 1])

    def query(self, l, r):
        l += self.n
        r += self.n
        s = self.e()
        while l < r:
            if l & 1:
                s = self.op(s, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                s = self.op(s, self.tree[r])
            l >>= 1
            r >>= 1
        return s

# Range Maximum Query
class RMQ(SegTree):
    def op(x, y):
        return max(x, y)
    def e():
        return -float('INF')
    def __init__(self, init_tree):
        super().__init__(init_tree, RMQ.op, RMQ.e)

# Range minimum Query
class RmQ(SegTree):
    def op(x, y):
        return min(x, y)
    def e():
        return float('INF')
    def __init__(self, init_tree):
        super().__init__(init_tree, RmQ.op, RmQ.e)


class MultiSet:
    def __init__(self, n):
        self.n = n
        self.cnt = defaultdict(int)
        self.segtree_min = RmQ([n - 1]*self.n)
        self.segtree_max = RMQ([0]*self.n)
        self.n_stock = 0

    def add(self, x):
        if self.cnt[x] == 0:
            self.segtree_min.update(x, x)
            self.segtree_max.update(x, x)
        self.cnt[x] += 1
        self.n_stock += 1

    def delete(self, x):
        self.cnt[x] -= 1
        if self.cnt[x] == 0:
            self.segtree_min.update(x, self.n - 1)
            self.segtree_max.update(x, 0)
        self.n_stock = max(self.n_stock - 1, 0)

    def pop_max(self):
        x_max = self.segtree_max.query(0, self.n - 1)
        self.delete(x_max)
        return x_max

    def pop_min(self):
        x_min = self.segtree_min.query(0, self.n - 1)
        self.delete(x_min)
        return x_min

    def search_max(self):
        return self.segtree_max.query(0, self.n - 1)

    def search_min(self):
        return self.segtree_min.query(0, self.n - 1)

    def lower_bound(self, x):
        return self.segtree_max.query(0, x)

    def upper_bound(self, x):
        return self.segtree_min.query(x, self.n)

    def contains(self, x):
        return bool(self.cnt[x])

    def size(self):
        return self.n_stock

    def empty(self):
        return self.n_stock == 0





def solve(N: int, K: int, Q: int, X: "List[int]", Y: "List[int]"):

    a_list = [0] * N

    # memory error (segtree を使った構造には限界がある。。。)
    stage = MultiSet(10 ** 5)
    stock = MultiSet(10 ** 5)
    score = 0

    for _ in range(K):
        stage.add(0)

    def add(y):
        nonlocal stock
        stock.add(y)
        migrate()

    def erase(y):
        nonlocal stage, stock, score
        if stage.contains(y):
            score -= y
            stage.delete(y)
        elif stock.contains(y):
            stock.delete(y)
        migrate()

    def migrate():
        nonlocal stage, stock, score

        while stage.size() < K:
            num = stock.pop_max()
            score += num
            stage.add(num)

        if stage.empty() or stock.empty():
            return

        while stage.search_min() < stock.search_max():
            stage_pop = stage.pop_min()
            stock_pop = stock.pop_max()
            stage.add(stock_pop)
            stock.add(stage_pop)
            score += (stock_pop - stage_pop)

    for x, y in zip(X, Y):
        x -= 1

        add(y)
        erase(a_list[x])

        a_list[x] = y

        print(score)



# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, K, Q, X, Y)

if __name__ == '__main__':
    main()
