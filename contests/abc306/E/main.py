#!/usr/bin/env python3
import sys
from collections import defaultdict
INF = float('inf')  # type: float


from heapq import heappop, heappush
from collections import defaultdict


class MultiSet:
    def __init__(self):
        self.n_size = 0
        self.cnt_dict = defaultdict(int)
        self.pos = []
        self.neg = []

    def add(self, x, key=None):
        key = x if key is None else key
        heappush(self.pos, (x, key))
        heappush(self.neg, (-x, key))
        self.cnt_dict[key] += 1
        self.n_size += 1

    def erase(self, key):
        if self.contains(key):
            self.cnt_dict[key] = max(self.cnt_dict[key] - 1, 0)
            self.n_size = max(self.n_size - 1, 0)

    def pop_max(self, is_return_key=False):
        while self.neg:
            x, key = heappop(self.neg)
            if self.contains(key):
                self.cnt_dict[key] = max(self.cnt_dict[key] - 1, 0)
                self.n_size = max(self.n_size - 1, 0)
                return (-x, key) if is_return_key else -x
        return (None, None) if is_return_key else None

    def pop_min(self, is_return_key=False):
        while self.pos:
            x, key = heappop(self.pos)
            if self.contains(key):
                self.cnt_dict[key] = max(self.cnt_dict[key] - 1, 0)
                self.n_size = max(self.n_size - 1, 0)
                return (x, key) if is_return_key else x
        return (None, None) if is_return_key else None

    def get_max(self, is_return_key=False):
        while self.neg:
            x, key = self.neg[0]
            if self.contains(key):
                return (-x, key) if is_return_key else -x
            else:
                heappop(self.neg)
        return (None, None) if is_return_key else None

    def get_min(self, is_return_key=False):
        while self.pos:
            x, key = self.pos[0]
            if self.contains(key):
                return (x, key) if is_return_key else x
            else:
                heappop(self.pos)
        return (None, None) if is_return_key else None

    def contains(self, key):
        return bool(self.cnt_dict[key])

    def size(self):
        return self.n_size

    def empty(self):
        return self.n_size == 0



def solve(N: int, K: int, Q: int, X: "List[int]", Y: "List[int]"):

    a_list = [0] * N

    stage = MultiSet()
    stock = MultiSet()
    score = 0

    for _ in range(K):
        stage.add(0)

    def add(y):
        nonlocal stock
        stock.add(y)
        migrate()

    def erase(y):
        nonlocal stage, stock, score
        if stage.contains(y):
            score -= y
            stage.erase(y)
        elif stock.contains(y):
            stock.erase(y)
        migrate()

    def migrate():
        nonlocal stage, stock, score

        while stage.size() < K:
            num = stock.pop_max()
            score += num
            stage.add(num)

        if stage.empty() or stock.empty():
            return

        while stage.get_min() < stock.get_max():
            stage_pop = stage.pop_min()
            stock_pop = stock.pop_max()
            stage.add(stock_pop)
            stock.add(stage_pop)
            score += (stock_pop - stage_pop)

    for x, y in zip(X, Y):
        x -= 1

        add(y)
        erase(a_list[x])

        a_list[x] = y

        print(score)



# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, K, Q, X, Y)

if __name__ == '__main__':
    main()
